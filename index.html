<!DOCTYPE html>
<html lang="en">

<head>
    <title>Oimo.js Basic</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="IE=11" />


    <link rel="shortcut icon" href="js/ribbon.png">

    <link rel="stylesheet" href="js/demo.css">

    <script src="js/demo.js"></script>
    <script src="js/three.js"></script>
    <script src="js/OrbitControls.js"></script>
    <script src="js/oimo.js"></script>

</head>

<body>
    <canvas id="canvas"></canvas>
    <div id='interface'>
        <input type="button" value="sphere" onClick=populate(1)>
        <input type="button" value="box" onClick=populate(2)>
        <input type="button" value="cylinder" onClick=populate(3)>
        <input type="button" value="mix" onClick=populate(4)>
        <input type="number" name="quantity" min="10" max="2000" value="2" id='MaxNumber'>
        <input type="submit" onClick=populate()>
        <input type="number" name="gravity" min="-20" max="20" value="-10" id='gravity' onChange=gravity()>
    </div>
    <div id='info'></div>
    <img style="position: absolute; top: 0; right: 0; border: 0;" src="js/ribbon.png"></a>
    <a id="ribbon" href="https://github.com/lo-th/Oimo.js"></a>
    <script>

        demolink();

        // three var
        var camera, scene, light, renderer, canvas, controls;
        var meshs = [];
        var grounds = [];
        var arrowHelper;

        var isMobile = false;
        var antialias = true;

        var geos = {};
        var mats = {};

        //oimo var
        var world = null;
        var bodys = [];

        var fps = [0, 0, 0, 0];
        var ToRad = 0.0174532925199432957;
        var type = 1;
        var infos;

        init();
        loop();

        var raycaster = new THREE.Raycaster();

        var mouse = new THREE.Vector2();

        function onMouseDown(event) {

            // calculate mouse position in normalized device coordinates
            // (-1 to +1) for both components

            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = - (event.clientY / window.innerHeight) * 2 + 1;

            raycaster.setFromCamera(mouse, camera);

            // calculate objects intersecting the picking ray
            var intersects = raycaster.intersectObjects(scene.children);

            for (var i = 0; i < intersects.length; i++) {

                intersects[i].object.material.color.set(0xff0000);
                arrowHelper.setColor(new THREE.Color(0xff0000));

            }

        }

        function render() {

            // update the picking ray with the camera and mouse position
            raycaster.setFromCamera(mouse, camera);

            // calculate objects intersecting the picking ray
            var intersects = raycaster.intersectObjects(scene.children);

            for (var i = 0; i < intersects.length; i++) {

                intersects[i].object.material.color.set(0xff0000);

            }

            renderer.render(scene, camera);

        }

        window.addEventListener('mousedown', onMouseDown, false);

        //window.requestAnimationFrame(render);


        function init() {

            var n = navigator.userAgent;
            if (n.match(/Android/i) || n.match(/webOS/i) || n.match(/iPhone/i) || n.match(/iPad/i) || n.match(/iPod/i) || n.match(/BlackBerry/i) || n.match(/Windows Phone/i)) { isMobile = true; antialias = false; document.getElementById("MaxNumber").value = 200; }

            infos = document.getElementById("info");

            canvas = document.getElementById("canvas");

            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 1, 5000);
            camera.position.set(0, 160, 400);

            controls = new THREE.OrbitControls(camera, canvas);
            controls.target.set(0, 20, 0);
            controls.update();

            scene = new THREE.Scene();

            renderer = new THREE.WebGLRenderer({ canvas: canvas, precision: "mediump", antialias: antialias });
            renderer.setSize(window.innerWidth, window.innerHeight);

            var materialType = 'MeshBasicMaterial';

            if (!isMobile) {

                scene.add(new THREE.AmbientLight(0x3D4143));
                light = new THREE.DirectionalLight(0xffffff, 1.4);
                light.position.set(300, 1000, 500);
                light.target.position.set(0, 0, 0);
                light.castShadow = true;

                var d = 300;
                light.shadow.camera = new THREE.OrthographicCamera(-d, d, d, -d, 500, 1600);
                light.shadow.bias = 0.0001;
                light.shadow.mapSize.width = light.shadow.mapSize.height = 1024;

                scene.add(light);

                materialType = 'MeshPhongMaterial';

                renderer.shadowMap.enabled = true;
                renderer.shadowMap.type = THREE.PCFShadowMap;//THREE.BasicShadowMap;
            }

            // background
            var buffgeoBack = new THREE.BufferGeometry();
            buffgeoBack.fromGeometry(new THREE.IcosahedronGeometry(3000, 2));
            var back = new THREE.Mesh(buffgeoBack, new THREE.MeshBasicMaterial({ map: gradTexture([[0.75, 0.6, 0.4, 0.25], ['#1B1D1E', '#3D4143', '#72797D', '#b0babf']]), side: THREE.BackSide, depthWrite: false, fog: false }));
            //back.geometry.applyMatrix(new THREE.Matrix4().makeRotationZ(15*ToRad));
            scene.add(back);

            // geometrys
            geos['sphere'] = new THREE.BufferGeometry().fromGeometry(new THREE.SphereGeometry(1, 16, 10));
            geos['box'] = new THREE.BufferGeometry().fromGeometry(new THREE.BoxGeometry(1, 1, 1));
            geos['cylinder'] = new THREE.BufferGeometry().fromGeometry(new THREE.CylinderGeometry(1, 1, 1));

            // materials
            mats['sph'] = new THREE[materialType]({ shininess: 10, map: basicTexture(0), name: 'sph' });
            mats['box'] = new THREE[materialType]({ shininess: 10, map: basicTexture(2), name: 'box' });
            mats['cyl'] = new THREE[materialType]({ shininess: 10, map: basicTexture(4), name: 'cyl' });
            mats['ssph'] = new THREE[materialType]({ shininess: 10, map: basicTexture(1), name: 'ssph' });
            mats['sbox'] = new THREE[materialType]({ shininess: 10, map: basicTexture(3), name: 'sbox' });
            mats['scyl'] = new THREE[materialType]({ shininess: 10, map: basicTexture(5), name: 'scyl' });
            mats['ground'] = new THREE[materialType]({ shininess: 10, color: 0x3D4143, transparent: true, opacity: 0.5 });

            // events

            window.addEventListener('resize', onWindowResize, false);

            // physics

            initOimoPhysics();



        }

        function loop() {

            updateOimoPhysics();
            renderer.render(scene, camera);
            requestAnimationFrame(loop);
        }

        function onWindowResize() {

            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);

        }

        function addStaticBox(size, position, rotation) {
            var mesh = new THREE.Mesh(geos.box, mats.ground);
            mesh.scale.set(size[0], size[1], size[2]);
            mesh.position.set(position[0], position[1], position[2]);
            mesh.rotation.set(rotation[0] * ToRad, rotation[1] * ToRad, rotation[2] * ToRad);
            scene.add(mesh);
            grounds.push(mesh);
            mesh.castShadow = true;
            mesh.receiveShadow = true;
        }

        function clearMesh() {
            var i = meshs.length;
            while (i--) {
                scene.remove(meshs[i]);
            }
            scene.remove(arrowHelper);
            i = grounds.length;
            while (i--) scene.remove(grounds[i]);
            grounds = [];
            meshs = [];
        }

        //----------------------------------
        //  OIMO PHYSICS
        //----------------------------------

        function initOimoPhysics() {

            // world setting:( TimeStep, BroadPhaseType, Iterations )
            // BroadPhaseType can be 
            // 1 : BruteForce
            // 2 : Sweep and prune , the default 
            // 3 : dynamic bounding volume tree

            world = new OIMO.World({ info: true, worldscale: 100 });
            populate(1);
            //setInterval(updateOimoPhysics, 1000/60);

        }

        function populate(n) {

            var max = document.getElementById("MaxNumber").value;

            if (n === 1) type = 1
            else if (n === 2) type = 2;
            else if (n === 3) type = 3;
            else if (n === 4) type = 4;

            // reset old
            clearMesh();
            world.clear();
            bodys = [];

            //add ground
            var ground0 = world.add({ size: [40, 40, 390], pos: [-180, 20, 0], world: world });
            var ground1 = world.add({ size: [40, 40, 390], pos: [180, 20, 0], world: world });
            var ground2 = world.add({ size: [400, 80, 400], pos: [0, -40, 0], world: world });

            addStaticBox([40, 40, 390], [-180, 20, 0], [0, 0, 0]);
            addStaticBox([40, 40, 390], [180, 20, 0], [0, 0, 0]);
            addStaticBox([400, 80, 400], [0, -40, 0], [0, 0, 0]);

            //add object
            var x, y, z, w, h, d;
            var i = max;

            while (i--) {
                if (type === 4) t = Math.floor(Math.random() * 3) + 1;
                else t = type;
                x = -100 + Math.random() * 200;
                z = -100 + Math.random() * 200;
                y = 100;//+ Math.random()*1000;
                w = 10 + Math.random() * 10;
                h = 10 + Math.random() * 10;
                d = 10 + Math.random() * 10;

                if (t === 1) {
                    bodys[i] = world.add({ type: 'sphere', size: [w * 0.5], pos: [x, y, z], move: true, world: world });
                    meshs[i] = new THREE.Mesh(geos.sphere, mats.sph);
                    meshs[i].scale.set(w * 0.5, w * 0.5, w * 0.5);
                } else if (t === 2) {
                    bodys[i] = world.add({ type: 'box', size: [w, h, d], pos: [x, y, z], move: true, world: world });
                    meshs[i] = new THREE.Mesh(geos.box, mats.box);
                    meshs[i].scale.set(w, h, d);
                } else if (t === 3) {
                    bodys[i] = world.add({ type: 'cylinder', size: [w * 0.5, h], pos: [x, y, z], move: true, world: world });
                    meshs[i] = new THREE.Mesh(geos.cylinder, mats.cyl);
                    meshs[i].scale.set(w * 0.5, h, w * 0.5);
                }

                meshs[i].castShadow = true;
                meshs[i].receiveShadow = true;

                scene.add(meshs[i]);
            }

            var dir = new THREE.Vector3(1, 2, 0);
            //normalize the direction vector (convert to vector of length 1)
            dir.normalize();

            var origin = new THREE.Vector3(0, 0, 0);
            var length = 2;
            var hex = 0xffff00;
            arrowHelper = new THREE.ArrowHelper(dir, origin, length, hex);
            //

            meshs[0].add(arrowHelper);
            arrowHelper.setLength(5);
            //arrowHelper.setColor(0xffff00);
            arrowHelper.setColor(new THREE.Color(0xffff00));//https://github.com/spite/THREE.MeshLine/issues/39
            //scene.add(arrowHelper);
        }

        function updateOimoPhysics() {
            if (world == null) return;

            world.step();

            var x, y, z, mesh, body, i = bodys.length;

            while (i--) {
                body = bodys[i];
                mesh = meshs[i];

                if (!body.sleeping) {

                    mesh.position.copy(body.getPosition());
                    mesh.quaternion.copy(body.getQuaternion());

                    // change material
                    if (mesh.material.name === 'sbox') mesh.material = mats.box;
                    if (mesh.material.name === 'ssph') mesh.material = mats.sph;
                    if (mesh.material.name === 'scyl') mesh.material = mats.cyl;

                    // reset position
                    if (mesh.position.y < -100) {
                        x = -100 + Math.random() * 200;
                        z = -100 + Math.random() * 200;
                        y = 100 + Math.random() * 1000;
                        body.resetPosition(x, y, z);
                    }
                } else {
                    if (mesh.material.name === 'box') mesh.material = mats.sbox;
                    if (mesh.material.name === 'sph') mesh.material = mats.ssph;
                    if (mesh.material.name === 'cyl') mesh.material = mats.scyl;
                }
            }

            infos.innerHTML = world.getInfo();
        }

        function gravity(g) {
            nG = document.getElementById("gravity").value
            world.gravity = new OIMO.Vec3(0, nG, 0);
        }



    </script>
</body>

</html>